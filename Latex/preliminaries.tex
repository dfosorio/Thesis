\chapter{Preliminaries}
The main purpose of this chapter is to present the theoretical and technical background necessary to understand how the encoding from probabilistic Event-B models to probabilistic rewrite theories, presented in \cite{Olarte}, works. Moreover, it will also allow to understand the proposed adaptations to the tool in \cite{tool.website}, to perform simulations with MultiVeStA over the encoded Event-B models. Therefore, a short but sufficient definition of various concepts and tools, will be given. To guide the reader through the different sections of this chapter and facilitate its reading, the following section dependency is given:

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
roundnode/.style={circle, draw=blue!60, fill=green!5, very thick, minimum size=7mm},
squarednode/.style={rectangle, draw=red!60, fill=red!5, very thick, minimum size=5mm},
]
%Nodes
\node[roundnode] (main) {2.1};
\node[roundnode] (n2) [right=of main] {2.2};
\node[roundnode] (n3) [right=of n2] {2.3};
%-------------------------------------------------------------
\node[roundnode] (n6) [below=of n2] {2.6};
\node[roundnode] (n5) [below=of n6] {2.5};
\node[roundnode] (n4) [left=of n5] {2.4};
\node[roundnode] (n7) [right=of n5] {2.7};


%Lines
\draw[->] (main.east) -- (n2.west);
\draw[->] (n2.east) -- (n3.west);
%-------------------------------------------------------------
\draw[->] (n4.east) -- (n5.west);
\draw[->] (n5.east) -- (n7.west);
\draw[->] (n6.east) .. controls +(right:7mm) and +(up:7mm) .. (n7.north);
\draw[->] (n4.north) .. controls +(up:7mm) and +(left:7mm) .. (n6.west);
\end{tikzpicture}
    \caption{Section dependencies}
    \label{fig:sectionDependency}
\end{figure}

\section{Event-B}
%explain what event B is generally
Event-B \cite{Abrial2011,Butler2013} is a formal method for specifying and verifying properties about systems based on set theory and predicate logic. Specifications in Event-B are referred to as models, and they are semantically interpreted as discrete labeled transition system or LTS \cite{LTS}. The main components of an Event-B model are machines and contexts: machines contain the dynamic elements of the model, while contexts contain the static ones. Specifically, machines contain the system variables, invariants, theorems, variant and events. On the other hand, contexts contain carrier sets, constants, axioms and theorems. Both machines and contexts have different interactions between them. A machine can ``\textbf{see}" one or several contexts, meaning that the machine accesses the static elements specified in these contexts. Furthermore, machines can ``\textbf{refine}" other machines, which means that if a machine $M_2$ refines a machine $M_1$, then $M_2$ can use all the dynamic elements specified in $M_1$ and also create new ones that respect the properties defined in $M_1$ (for example properties defined as invariants). This relation also occurs in the same way between contexts, when one context ``\textbf{extends}" another one. The idea behind extending contexts and refining machines is to add new elements and more detail to the original specifications %explain what a Context is and syntax 
In terms of syntax, the general structure for contexts is depicted in Figure \ref{fig:eventb2}. The definition for each one of the elements of the syntax is:
\begin{itemize}
    \item \textit{context\_identifier} is a string that identifies the context. The context identifier must be different to all the other identifiers of the components of the system (other machines or contexts).
    \item The ``\textbf{extends}" clause lists all the contexts identifiers that the current context is extending.
    \item The ``\textbf{sets}" clause takes a list of set identifiers. Each one of these set identifiers correspond to the name of one of the carrier sets of the model. A carrier set is a user defined  non-empty set. The set of set identifiers of a model is defined as $\bar{s} = \{s_1...s_n\}$. 
    \item The ``\textbf{constants}" clause lists all the constants of the model. The set of constants identifiers is defined as $\bar{c} = \{c_1...c_n\}$.
    \item The ``\textbf{axioms}" clause introduces the list of axioms that the model must satisfy. The Axioms are a conjunction of predicates over sets $\bar{s}$ and constants $\bar{c}$ defined as $A(\bar{s},\bar{c})$. These logic predicates state the properties that the constants and sets must meet.
    \item The ``\textbf{theorems}" clause lists some logic predicates, that must be proved within the context using the axioms. These are logic predicates defined as $T_i(\bar{s},\bar{c})$.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.5]{images/eventb2.PNG}
    \caption{Context structure, taken from \cite{Abrial2011}}
    \label{fig:eventb2}
\end{figure}

%explain what a Machine is and syntax
The general structure of the machine is specified in Figure \ref{fig:eventb3}. Each one of its components correspond to:
\begin{itemize}
    \item \textit{machine\_identifier} is a string that identifies the machine. It must be different from all the other components identifiers.
    \item The ``\textbf{refines}" clause contains the identifier of the machine that this machine refines.
    \item Clause ``\textbf{sees}" lists the context that the machine is referencing. When a machine ``sees" a context, it means that it can use the sets and constants defined in the context.
    \item The clause ``\textbf{variables}" lists all the variables of the system. The set of variable identifiers is defined as $\bar{v} = \{v_1...v_n\}$.
    \item The ``\textbf{invariants}" clause lists all the invariants that the model must satisfy. Invariants are represented as a conjunction of logic predicates over variables $\bar{v}$, defined as $I(\bar{v})$. These invariants define the properties that the variables must hold in every configuration or state of the system.
    \item The ``\textbf{theorems}" clause lists all the theorems. Each theorem is a logic predicates that must be proven using the axioms of the context and the invariants of the machine. They have the form $T_i(\bar{v})$.
    \item The ``\textbf{variant}" clause is used when machines have \textit{convergent events}. It specifies an expression $V(\bar{v})$ over the variables used for proving convergence of the model.
    \item The ``\textbf{events}" clause lists the events of the model. Each event represents a system transition, that changes the current system state to another.
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.5]{images/eventb3.PNG}
    \caption{Machine structure, taken from \cite{Abrial2011}}
    \label{fig:eventb3}
\end{figure}


Events are very important components of an Event-B model and they have the following structure:
\begin{align*}
    \textbf{event} \; e \; \textbf{any} \; \bar{t} \; \textbf{where} \; G(\bar{t}, \bar{v}) \; \textbf{then} \; S(\bar{t}, \bar{v}) \; \textbf{end} 
\end{align*}
\begin{itemize}
    \item $e$ is the \textit{event\_identifier}, which is a string that identifies the event.
    \item The ``\textbf{any}" clause lists the parameters of the event. These parameters represent unknown values, conditioned by the guards of the event. The set of parameters of an event is represented by $\bar{t} = \{t_1,...,t_n\}$.
    \item The ``\textbf{where}" clause contains the guards of the event. Guards are represented as a conjunction of logic predicates $G(\bar{t}, \bar{v})$ over the parameters of the event and variables of the system. These guards specify the conditions that must hold for the event to be enabled.
    \item The ``\textbf{then}" clause contains the list of actions of the event. Actions define variable assignments that change the variable values (and thus the state of the system) when the event is executed. These actions are represented as a set of assignments $S(\bar{t}, \bar{v})$.
\end{itemize} 
%explain what is an action
Event assignments can be categorized in three types:
\begin{itemize}
    \item Deterministic assignment $x := E(\bar{t},\bar{v})$ states that if the event is executed, then the value of variable $x$ in the next state will be $E(\bar{t},\bar{v})$, where $E$ is an expression over the parameters of the event and the variables of the system.
    \item Non-deterministic assignment $x :\in  \{ E_1(\bar{t},\bar{v})... E_n(\bar{t},\bar{v}) \}$ called enumerated assignment. In this case, one of the expressions $E_i$ of the set is assigned non-deterministically to variable $x$, when the event is executed.
    \item Non-deterministic assignment $x :\! | \; Q(\bar{t}, \bar{v}, x, x')$ denoted as predicate assignment. It assigns to variable $x$ a value denoted by $x'$, s.t. $x'$ satisfies the predicate $Q(\bar{t}, \bar{v}, x, x')$.
\end{itemize}
The set of events of a model is called as $Evts$. This set includes the \textit{INITIALISATION} event or $Init$, which assigns the initial value to all the variables of the machine and creates the initial state of the model. The initial state must be deterministic in all Event-B specifications. A whole Event-B model can be represented as a context $\mathscr{C} = (\bar{s},\bar{c}, A(\bar{s},\bar{c}))$ and a machine $\mathscr{M} =(\bar{v}, I(\bar{v}), V(\bar{v}), Evts, Init)$.
%provide a simple example
To clarify this notation, an example of an Event-B model of a brake system, presented in \cite{Aouadhi2017}, will be used. 

\begin{example}
\normalfont
A brake system (derived from the example presented in \cite{Aouadhi2017}) consists of two parts: a pedal and a brake. The pedal can be \textit{up} or \textit{down}, and the brake can be \textit{applied} or \textit{released}. When the pedal is \textit{up}, the brake is \textit{released}. When the pedal is \textit{down}, the brake is then \textit{applied}. The resulting Event-B specification for such model is represented in Figure \ref{fig:brake1} and \ref{fig:brake2}.
\begin{figure}[H]
    \centering
    \frame{{\includegraphics[scale = 0.3]{images/eventb4.PNG} }}
    \caption{Context of the brake example}
    \label{fig:brake1}
\end{figure}
\begin{figure}[H]
    \centering
    \subfloat{\frame{{\includegraphics[scale = 0.3]{images/eventb5.PNG} }}}
    \quad
    \subfloat{\frame{{\includegraphics[scale = 0.3]{images/eventb6.PNG} }}}
    \quad
    \subfloat{\frame{{\includegraphics[scale = 0.3]{images/eventb7.PNG} }}}
    \caption{Machine of the brake example}
    \label{fig:brake2}
\end{figure}
The context identifier for this model is \textit{ctxBrakeSystem}, the set of set identifiers is $\bar{s} = \{pedalState, brakeState\}$ and the set of constants is $\bar{c} = \{up, down, applied, released \}$. The $pedalState$ carrier set contains the possible states of the pedal ($up$ or $down$) and the $brakeState$ carrier set contains the possible states of the brake ($applied$ or $released$). Both of these sets, are defined using the axioms $axm1$ and $axm2$. Therefore, the axioms of the brake model are defined by $A(\bar{s},\bar{c}) = axm1 \land axm2$. This context does not extend other components or uses theorems. 

For the model's machine, the machine identifier is \textit{abstractBrakeSystem} and it ``sees" the sets, constants and axioms in \textit{ctxBrakeSystem}. The set of variables in the brake model is defined as $\bar{v} = \{pedal, brake\}$. The $pedal$ variable represents the pedal's state and the $brake$ variable represents the brake's state. Invariants $inv1$ and $inv2$ define the domain for variables $pedal$ and $brake$ respectively, by assigning to each one of them their respective carrier set. The resulting invariant for the brake model is $I(\bar{v}) = inv1 \land inv2$. Each one of the events in the model represent a state transition and a system action:
\begin{itemize}
    \item The \textit{INITIALISATION} determines the initial state of the system. In this case, the action $S(\bar{t}, \bar{v})$ of the \textit{INITIALISATION} event is defined by the two assignments $pedal := up$ and $brake := released$.
     
    \item The \textit{PushPedal} event represents the action of pushing the pedal. The guard of the event $G(\bar{t}, \bar{v}) = grd1$ checks that the pedal must be \textit{up}, to execute the action $S(\bar{t}, \bar{v}) = act1$. This action assigns the value \textit{down} to the \textit{pedal} variable. Conversely, the \textit{ReleasePedal} event verifies that the \textit{pedal} variable is \textit{down}, and changes its value to \textit{up} when executed.
    
    \item The \textit{ApplyBrake} event represents the action of applying the brake. The guard of the event $G(\bar{t}, \bar{v}) = grd1 \land grd2$ states that the pedal must be \textit{down} and the brake \textit{released}, to execute the action $S(\bar{t}, \bar{v}) = act1$. This action assigns the value \textit{applied} to the \textit{brake} variable. On the other hand, the \textit{ReleaseBrake} check for the opposite conditions ($pedal = up$ and $brake = applied$) and changes the value of the \textit{brake} variable to \textit{released}. 
\end{itemize}
\end{example}


\section{Non-deterministic choices in Event-B}
When an Event-B model is simulated or verified, there exists the possibility of having multiple enabled transitions with also many possible parameter valuations that satisfy the guards of the event. The way Event-B resolves this multiple choice dilemma is with \textit{non-deterministic choice} and there are three types of it:
\begin{itemize}
    \item \textbf{Choice of enabled events:} When multiple events are enabled for execution, i.e. when multiple events satisfy their event guards, one of them is chosen non-deterministically.  
    \item \textbf{Choice of parameter values:} In an event with parameters, it is possible to have multiple valuations for parameters $\bar{t}$ such that the guard of the event $G_i(\bar{t}, \bar{v})$ is satisfied. Therefore, the parameter that will be used in the execution of the event is chosen non-deterministically
    \item \textbf{Non-Deterministic assignments:} As mentioned before, there are 3 types of event assignments: deterministic assignment, predicate assignment and enumerated assignment. Both predicate and enumerated assignments, are non-deterministic for the following reason:
    \begin{itemize}
        \item Predicate assignment $x :\! | \; Q(\bar{t}, \bar{v}, x, x')$: states that the variable $x$ takes the value $x'$, that satisfies the predicate $Q(\bar{t}, \bar{v}, x, x')$. When there are multiple $x'$ values that satisfy the predicate, then the new value of $x$ is chosen non-deterministically.
        \item Enumerated assignment $x :\in  \{ E_1(\bar{t},\bar{v})... E_n(\bar{t},\bar{v}) \}$: states that the variable $x$ takes the value of one of the multiple expressions $E_i(\bar{t},\bar{v})$ in the set. The selection of which expression will be assigned, is done non-deterministically. 
    \end{itemize}
\end{itemize}

\section{Probabilistic Event-B}
Based on the three different forms of non-determinism explained above, probabilistic Event-B \cite{Aouadhi2017} introduces probabilistic choices to replace non-deterministic ones in the following way:
\begin{itemize}
    \item \textbf{Probabilistic choice of enabled events:} To solve the non-determinisim, an expression $W_{e_i}(\bar{v})$ over the variables represents the \textit{weight} of a specific event $e_i$. Therefore, when multiple events are enabled, the probability of choosing one of them will be the ratio of its weight over the sum of all the weights of enabled events. This means that if there are $n$ enabled events, then the probability of choosing event $e_i$ is $P(e_i) = \frac{W_{e_i}(\bar{v})}{\sum^{n}_{j = 1}W(e_j)}$
    \item \textbf{Probabilistic choice of parameter values:} In order to choose a parameter value probabilistically, a discrete uniform distribution can be used as a default choice to assign probabilities to the parameters. For that reason, the probability of choosing a parameter valuation is $P(t_i) = \frac{1}{n}$ where $n$ is the number of parameter valuations that satisfy the guard of the event.
    \item \textbf{Predicate probabilistic assignment:} A predicate probabilistic assignment written as $x:\! \oplus \; Q(\bar{t}, \bar{v}, x, x')$ chooses the new value of $x$ with a uniform distribution. Hence, the probability of choosing a variable value $x'_i$ is $P(x'_i) = \frac{1}{n}$ where $n$ is the number of variable valuations that satisfy the predicate $Q(\bar{t}, \bar{v}, x, x')$. This probabilistic assignment replaces the non-deterministic predicate assignment. 
    \item \textbf{Enumerated probabilistic assignment:} A enumerated probabilistic assignment written as $x := E_1(\bar{t},\bar{v})@_{p_1}\oplus...\oplus E_n(\bar{t},\bar{v})@_{p_n}$  assigns a specific probability $p_i$ to each expression $E_i$, where $0 < p_i \leq 1$ and $p_1 + ... + p_n = 1$. This probabilistic assignment replaces the non-deterministic enumerated assignment.
\end{itemize}
The new structure for probabilistic events can be defined as:
\begin{align*}
    e \; \equalhat \; \textbf{weight} \; W( \bar{v}) \; \textbf{any} \; \bar{t} \; \textbf{where} \; G(\bar{t}, \bar{v}) \; \textbf{then} \; S(\bar{t}, \bar{v}) \; \textbf{end} 
\end{align*}
Where $W( \bar{v})$ is an expression over the variables that determines the weight of the event, $\bar{t}$ is the set of parameters of the event, $G(\bar{t}, \bar{v})$ the guard of the event and $S(\bar{t}, \bar{v})$ is the \textit{probabilistic action}. The probabilistic action contains only deterministic assignments, predicate probabilistic assignments and enumerated probabilistic assignments. The resulting machine for a probabilistic model is then $\mathscr{M} =(\bar{v}, I(\bar{v}), V(\bar{v}), PEvts, Init)$ where $PEvts$ is a set of probabilistic events and $Init$ is the initialization event ($Init$ must be a deterministic event). To exemplify probabilistic Event-B, let's consider an extension of the previously explained brake model. 

\begin{example}
\normalfont
This new example, taken from \cite{Aouadhi2017}, adds new constraints:
\begin{itemize}
    \itema Pedal failure: when the driver tries to switch “down” the pedal, it may stay in the same position.
    \itemb Risk of pedal failure: the risk of pedal failure is set to 10\%.
    \itemc Brake failure: the brake may not be applied, although the pedal has been switched down.
    \itemd Maximum brake wear: the brake cannot be applied more than a fixed number of times.
    \iteme Brake wear: due to brake wear, the risk of brake failure increases each time the brake is applied.
\end{itemize}
The resulting probabilistic model is depicted in Figure \ref{fig:brake3}. This new model incorporates all of the previously defined constraints in the following way:
\begin{itemize}
    \item Constraints \textbf{R1} and \textbf{R2} are modeled in the probabilistic event \textit{PushPedal}, in which an enumerated probabilistic assignment is used to assign the value of variable \textit{pedal}. This assignment $pedal := down \ @9/10  \ \oplus \ up \ @1/10$ states that when the event \textit{PushPedal} is executed, the probability of changing its value to \textit{down} is $90\%$ and the probability of remaining with the value \textit{up} is $10\%$.
    \item For \textbf{R4}, a new constant \textit{MAX\_WEAR} s.t. \textit{MAX\_WEAR} $\in \mathbb{N}$ and \textit{MAX\_WEAR} $> 1$, is introduced to the context of the model. This constant determines the maximum number of times the break can be applied. In addition, the variable \textit{wear} $\in \mathbb{N}$ tracks the number of times the brake has been used. To make sure that the number of times the break has been applied doesn't exceeds the maximum wear, i.e. \textit{wear} $<$ \textit{MAX\_WEAR}, the weights of probabilistic events \textit{ApplyBrake} and \textit{ReleaseBrake} are modeled by the expression \textit{MAX\_WEAR} $-$ \textit{wear}. Therefore, when \textit{MAX\_WEAR} $=$ \textit{wear}, the weight of both events will be 0. This will make their probability of execution also 0, based on how probabilistic choice of enabled events is calculated.
    \item To model \textbf{R3}, a new event \textit{ApplyBrakeFailure} is introduced. When executed, this event simulates a brake failure, by leaving the brake in state \textit{released} when the pedal is \textit{down}.
    \item Finally, the constraint \textbf{R5} is defined by the weights of event \textit{ApplyBrake} and \textit{ApplyBrakeFailure}. As mentioned before, the weight of event \textit{ApplyBrake} is modeled with the expression \textit{MAX\_WEAR} $-$ \textit{wear}, and the expression for the weight of event \textit{ApplyBrakeFailure} is \textit{wear}. Thus, when the value of variable \textit{wear} increases, then the probability of executing event \textit{ApplyBrake} decreases and the probability of \textit{ApplyBrakeFailure} increases. 
    
    \end{itemize}
\begin{figure}[h]
    \centering
    \subfloat{\frame{{\includegraphics[scale = 0.3]{images/eventb8.PNG} }}}
    \quad
    \subfloat{\frame{{\includegraphics[scale = 0.3]{images/eventb9.PNG} }}}
    \quad
    \subfloat{\frame{{\includegraphics[scale = 0.3]{images/eventb10.png} }}}
    \caption{Probabilistic machine of the brake example, taken from \cite{Aouadhi2017}}
    \label{fig:brake3}
\end{figure}


\end{example}


\section{Maude}
%Main sources for this chapter: PeterMaude, Lecture1, Lecture3

%explain the generality of Maude
Maude \cite{MaudeManual, PeterMaude, Lecture1} is a high performance declarative language, that allows the specification of programs, dynamic systems or logics, and their verification.
%explain how Maude program are written in functional module (sorts, subsorts, ops, etc, equations and equation evaluation)
Maude's specifications are represented as \textit{functional modules} declared with syntax: \\
\begin{maude}
fmod MODULENAME is
    BODY
endfm
\end{maude}
where \textit{MODULENAME} is the name of the functional module, and \textit{BODY} is a set of declarations that specify the specification. The body of the module contains \textit{sorts} (written in Maude as \texttt{sorts}), where each sort correspond to a specific data type. It also contains a set of function symbols or function declarations called \textit{operators} (abbreviated as \texttt{op} in Maude), that specify the constructors of the different sorts, along with the syntax of the specification's functions. Finally, a set of \textit{equations} (abbreviated as \texttt{eq} in Maude) is used to define the meaning of the functions. These equations use \textit{variables} (abbreviated as \texttt{var} in Maude). 

%provide an example of a maude program functional module
To illustrate how a Maude specification is contructed, the following code corresponds to a functional module that defines the natural numbers and the addition operation, borrowed from \cite{PeterMaude,Lecture1}: 
\\
\begin{maude}
fmod NAT-ADD is
  sort Nat .

  op 0 : -> Nat [ctor] .
  op s : Nat -> Nat [ctor] .
  op _+_ : Nat Nat -> Nat .

  vars N M : Nat .
    
  --- Recursive Definition for addition
  eq N + 0 = N .
  eq N + s(M) = s(N + M) .
endfm
\end{maude}
The sort \texttt{Nat} is a data type that represents the natural numbers. This sort has two constructors (represented in the code with the key word \texttt{ctor}): 0 which is a constant and the operator \texttt{s}, which takes one argument of type \texttt{Nat} and represents the successor function in the natural numbers. With these two operators, it is possible to define arithmetic functions in the natural numbers, like addition. In this case, the operation is defined inductively using 2 equations. Using this module, it is possible to compute the value for addition for two natural numbers using the command \texttt{red}. For example, if the command \texttt{red s(s(s(0))) + s(s(0))} is used (the command represents the operation 3 + 2), the answer 5 is obtained represented as \texttt{s(s(s(s(s(0)))))}:
\\
\begin{maude2}
*********** equation
eq N + s(M) = s(N + M) .
N --> s(s(s(0)))
M --> s(0)
s(s(s(0))) + s(s(0))
--->
s(s(s(s(0))) + s(0))
*********** equation
eq N + s(M) = s(N + M) .
N --> s(s(s(0)))
M --> 0
s(s(s(0))) + s(0)
--->
s(s(s(s(0))) + 0)
*********** equation
eq N + 0 = N .
N --> s(s(s(0)))
s(s(s(0))) + 0
--->
s(s(s(0)))
result Nat: s(s(s(s(s(0)))))
\end{maude2}
Maude computes using equations from left to right. Therefore, in computation steps like the first one, the expression \texttt{s(s(s(0))) + s(s(0))} is matched with the left side of the equation \texttt{N + s(M) = s(N + M)} and matching substitution $\{\texttt{N} \mapsto \texttt{s(s(s(0)))},\texttt{M} \mapsto \texttt{s(0)} \}$. The resulting expression \texttt{s(s(s(0))) + s(s(0))}, will be simplified again with the same equation, until it reduces to a simplified expression that can be matched with the equation \texttt{N + 0 = N} (as seen in the last step).

%explain the semantics behind the functional modules
Semantically, functional modules in Maude are \textit{equational theories} \cite{Lecture1,PeterMaude}, that are represented as a pair $(\Sigma, E)$ where: 
\begin{itemize}
    \item the \textit{signature} $\Sigma$ describes the syntax of the theory, which is the data types and operators symbols (sorts and operators).
    \item $E$ is the set of equations between expressions written in the syntax of $\Sigma$.
\end{itemize}
As mentioned before, computations in Maude are done by using the equations over expressions constructed with operators. This method is called \textit{term rewriting} \cite{Lecture1,PeterMaude} and behaves in the following way: 

\begin{itemize}
    \item With the equations $E$ of $(\Sigma, E)$, \textit{term rewriting rules} are defined as $\vv{E} = \{u \rightarrow v  \ | \ (u = v) \in E \}$. 
    \item A term $t$, which are expressions formed using the syntax in $\Sigma$, is rewritten to $t'$ in one step $t \rightarrow_{\vv{E}} t'$ if and only if, the following conditions are sufficed:
        \begin{itemize}
            \item there is a subterm $w$ in $t$, expressed as $t[w]$.
            \item there is a rule $(u \rightarrow v) \in \vv{E}$ and a substitution $\theta$ s.t. : $w = u\theta$, $w' = v\theta$, $t'=t[w']=t[v\theta]$.   
        \end{itemize}
\end{itemize}
As an example, taken from \cite{Lecture1}, in the previous computation \texttt{red s(s(s(0))) + s(s(0))} the term rewriting process in the second step, is the following:
\begin{itemize}
    \item $E = \texttt{N+s(M)=s(N + M)}$
    \item $t = \texttt{s(s(s(s(0))) + s(0))}$
    \item $\theta = \{\texttt{N} \mapsto \texttt{s(s(s(0)))},\texttt{M} \mapsto \texttt{0} \}$
    \item $w = \texttt{N+s(M)}\theta = \texttt{s(s(s(0))) + s(0)}$
    \item $w' = \texttt{s(N+M)}\theta = \texttt{s(s(s(s(0))) + 0)}$
    \item $t' = \texttt{s}([w']) = \texttt{s(s(s(s(s(0))) + 0))}$
\end{itemize}
the resulting term rewriting is $t \rightarrow_{\vv{E}} t'$.
%explain the functional modules with rewriting rules
%explain theory behind it
Aside from building specifications in Maude using functional modules, it is also possible to model concurrent systems. This is done with \textit{system modules}, which permit the construction of system states and transitions. Semantically, a system module is a \textit{rewrite theory} \cite{PeterMaude,Lecture3} $\mathscr{R} = (\Sigma, E, L, R)$ where: 
\begin{itemize}
    \item $(\Sigma, E)$ is an equational theory.
    \item $L$ is a set of labels.
    \item $R$ is a set of unconditional labeled rewrite rules of the form $l: t \rightarrow t'$, and conditional labeled rewrite rules of the form $l: t \rightarrow t' \ \text{if} \ cond$, where $l \in L$, $t,t'$ are terms in $\Sigma$ and $cond$ is a condition or system guard.    
\end{itemize}
The syntax for system modules in Maude is:
\\
\begin{maude}
mod MODULENAME is
    BODY
endm
\end{maude}
Where the body represents a rewrite theory $\mathscr{R}$. The syntax for unconditional rewriting rules is
\\
\begin{maude}
rl [$l$] : $t$ => $t'$ .
\end{maude}
and for conditional rewriting rules is
\\
\begin{maude}
crl [$l$] : $t$ => $t'$ if $cond$ .
\end{maude}
%provide an example of a model
To exemplify this, let's consider the following simple model of a bus.

\begin{example}
\normalfont
A transport bus has capacity for 60 people. The bus can be moving or stationary, and can only drop or lift passengers when the bus is stationary. Finally, at any time, the bus driver can use the brake to stop or use the gas pedal to move. The corresponding Maude system module for this model is:
\\
\begin{maude}
mod BUS is protecting NAT .
  sorts Bus Status .

  op bus : Nat Status -> Bus [ctor] .
  ops stationary moving : -> Status [ctor] .
 
  vars N M : Nat . var S : Status .

  --- move the bus
  rl [move] : bus(N,stationary) => bus(N,moving) .
  --- stop the bus 
  rl [stop] : bus(N,moving) => bus(N,stationary) .
  --- drop passenger
  rl [drop] : bus(s(N),stationary) => bus(N,stationary) .
  --- lift passenger
  crl [lift] : bus(N,stationary) => bus(s(N),stationary) 
                                    if s(N) <= 60 . 
endm
\end{maude}
%explain how the maude model corresponds to the theory
In this model the states of the system are represented with instances of the sort \texttt{Bus}. They contain a natural number that represents the number of people inside the bus and a \texttt{Status}, which represents the state of the bus (it can be \texttt{stationary} or \texttt{moving}). In this case, no equations are used, therefore the set of equations $E = \emptyset$  and $\Sigma$ will contain the sorts \texttt{Bus} and \texttt{Status} with their respective operators. To model the different events in the model, four rewriting rules were used:
\begin{itemize}
    \item An unconditional rule, labeled \texttt{move}, that represents the event of using the gas pedal to move the bus by changing the status from \texttt{stationary} to \texttt{moving}. Note that this rule can only be applied when the bus is \texttt{stationary}, as stated by the rule first term \texttt{bus(N,stationary)}.
    \item An unconditional rule, labeled \texttt{stop}, that represents the event of using the brakes to stop the bus. This changes the status of the bus from \texttt{moving} to \texttt{stationary}. As the previous rule, it can only be applied when the first term is matched, i.e. when the bus status is \texttt{moving}. 
    \item An unconditional rule, labeled \texttt{drop}, that represents the event of dropping people off the bus. The subterm \texttt{s(N)} assures that it can only drop a person when the number of people inside the bus is one or more. This rule rewrites the state of the system, by reducing the number of passengers in the bus by one.
    \item A conditional rule, labeled \texttt{lift}, that represents the event of lifting a passenger. When this rule is applied, the number of passengers inside the bus is increased by one. To prevent exceeding the maximum capacity of the bus, the condition \texttt{if s(N) <= 60} is used. 
\end{itemize}
With this system module, that represents a rewrite theory $\mathscr{R}$, the simple bus model can be verified using other functionalities in Maude like model checking with the commands \texttt{rewrite} and \texttt{search}. The \texttt{rewrite} command or \texttt{rew} takes an initial state of the system and uses the rewriting rules until termination, i.e. until no other rewriting rule can be applied to the system state. In the case of the bus example, the rules \texttt{move} and \texttt{stop} can be applied infinitely. Therefore, to be able to simulate the system, Maude also allows to use bounded rewriting. With this method, it is possible to specify the number of rewriting rules to be applied to the initial state of the system. For example, the command: 
\begin{maude}

rew [3] bus(0, stationary) .
\end{maude}
will apply 3 rewriting rules to the state \texttt{bus(0, stationary)}, which refers to a stationary bus with no passengers. The resulting execution is:
\\
\begin{maude2}
*********** rule
rl bus(N, stationary) => bus(N, moving) [label move] .
bus(0, stationary)
--->
bus(0, moving)
*********** rule
rl bus(N, moving) => bus(N, stationary) [label stop] .
bus(0, moving)
--->
bus(0, stationary)
*********** rule
crl bus(N, stationary) => bus(s N, stationary) 
                          if s N <= 60 = true [label lift] .
bus(0, stationary)
--->
bus(1, stationary)
result Bus: bus(1, stationary)
\end{maude2}
Lastly, with the \texttt{search} command it is possible to verify if a given state is reachable. For example, to check if the state \texttt{bus(10,stationary)} can be reached from the initial state \texttt{bus(0,moving)}, the command 
\begin{maude}

search bus(0,stationary) =>* bus(10, moving) .
\end{maude}
can be used. The result of this command is:
'\\
\begin{maude2}
search in BUS : bus(0, stationary) =>* bus(10, moving) .
Solution 1 (state 21)
states: 22  rewrites: 50 in 0ms cpu (0ms real) (~ rewrites/second)
empty substitution
No more solutions.
\end{maude2}
If the search returns a solution, it means that the state is reachable. Furthermore, it is also possible to check if the system will exceed the maximum capacity, defining a system invariant $I$ that states this property. This can be done, by adding the following code to the bus module:
\\
\begin{maude}
--- Define predicates
  var X : Bus .
  op predicate : Bus -> Bool .
  eq predicate(bus(N,S)) = if N <= 60 then true else false fi .
\end{maude}
This invariant can be checked with the \texttt{search} command using:
\\
\begin{maude2}
search bus(0,stationary) =>* X  s.t. predicate(X) =/= true .
\end{maude2}
which searches for a state \texttt{X} where the bus has more than 60 passengers. The resulting execution of the command returns no solution: \\
\begin{maude2}
search in BUS : bus(0, stationary) =>* 
                X such that predicate(X) =/= true = true .
No solution.
\end{maude2}
This means that the bus system cannot exceed the maximum capacity of the bus.


\end{example}


\section{Object-Based Programming in Maude}
Object-based programming in Maude \cite{MaudeManual, Lecture3, PeterMaude} is supported by a predefined module \texttt{CONFIGURATION}. This module contains the necessary sorts and syntax to define the objects, messages, system configurations and objects interactions, of an object-based system. This module is defined as:
\\
\begin{maude}
mod CONFIGURATION is
  --- basic object system sorts
  sorts Object Msg Configuration .
  --- construction of configurations
  subsort Object Msg < Configuration .
  op none : -> Configuration [ctor] .
  op _ _ : Configuration Configuration -> Configuration
           [ctor config assoc comm id: none] .
\end{maude}

The basic sorts are \texttt{Object}, \texttt{Msg} and \texttt{Configuration}. A term of sort \texttt{Object} represents an instance of a system object, a term of sort \texttt{Msg} represents a message shared by the system objects and a term of sort \texttt{Configuration} represents a snapshot of the current system state, represented as a multiset of objects and messages. These configurations are built with the multiset union operation (defined with syntax \texttt{\_\,\_} ) between objects, messages or other configurations, and the empty configuration is defined as \texttt{none}. The module configuration also implements a predefined syntax for object construction. They have the form:
\begin{align*}
    \langle O : C \ | \ a_1:v_1,...a_n:v_n \rangle
\end{align*}
Where $O$ is the object's identifier, $C$ is a class identifier, $a_1...a_n$ are attribute identifiers and $v_1...v_n$ are the values of each one of the attributes. This defined syntax in Maude is implemented as:
\\
\begin{maude}
  --- Maude object syntax
  sorts Oid Cid .
  sorts Attribute AttributeSet .
  subsort Attribute < AttributeSet .
  op none : -> AttributeSet [ctor] .
  op _,_ : AttributeSet AttributeSet -> AttributeSet
  [ctor assoc comm id: none] .
  op <_:_|_> : Oid Cid AttributeSet -> Object [ctor object] .
endm
\end{maude}
Where \texttt{Oid} corresponds to the object identifier $O$, \texttt{Cid} is the class identifier $C$ and the attributes of the object are represented as a multiset. Messages' syntax is defined by the user. To understand how systems are modeled in Maude with configurations, the bank account example in \cite{MaudeManual} can be examined.
%provide an example
\begin{example}
\normalfont
The \texttt{BANK-ACCOUNT} system module is defined as: 
\\
\begin{maude}
mod BANK-ACCOUNT is
    protecting INT .
    protecting CONFIGURATION .
    op Account : -> Cid [ctor] .
    op bal :_ : Int -> Attribute [ctor gather (&)] .
    op from_to_transfer_ : Oid Oid Nat -> Msg [ctor] .
    
    vars A B : Oid .
    vars M N L : Nat .

    --- Definition of transfer rewriting rule
    crl [transfer] :
      (from A to B transfer M)
      < A : Account | bal : N >
      < B : Account | bal : L >
      => < A : Account | bal : N - M >
         < B : Account | bal : L + M >
      if N >= M .

    --- Definition of the initial configuration
    op bankConf : -> Configuration .
    ops A-001 A-002 : -> Oid .
    eq bankConf
    = < A-001 : Account | bal : 250 >
      < A-002 : Account | bal : 1250 >
      (from A-002 to A-001 transfer 300) .
endm
\end{maude}
The system consists of different bank accounts, that can transfer money to each other. The \texttt{protecting} command is used to include the functional modules \texttt{INT} and \texttt{CONFIGURATION}, which include all the sorts, operators and equations defined in these modules, into the \texttt{BANK-ACCOUNT} system module. The bank account class is named as \texttt{Account}, and it contains the attribute \texttt{bal} which corresponds to the amount of money available in an account. The message \texttt{from\_to\_transfer\_} simulates the transfer request from one account to another, by specifying the two account object identifiers or Oid (one for the account that sends the money and the other one for the account that receives the money) and the amount of money to be sent as an integer. The rewrite rule \texttt{transfer} matches a system configuration where the message \texttt{from A to B transfer M} and the two accounts with Oid \texttt{A} and \texttt{B} are present. After that, the rule modifies the attribute \texttt{bal} of both accounts according to the transaction parameters and erases the message from the configuration. For example, if the initial configuration of the system is the one defined by \texttt{bankConf}, the result after using the rewriting command \texttt{rew in BANK-ACCOUNT : bankConf .} which rewrites the initial state using the rewriting rules until reaching a deadlock, would be:
\\
\begin{maude2}
result Configuration: < A-001 : Account | bal : 550 > 
                      < A-002 : Account | bal : 950 >
\end{maude2}

\end{example}

\section{PMaude}
%acknowledge the PMaude paper
%explain what PMaude is (probably use the thesis proposal)
Probabilistic Maude or PMaude \cite{Agha2006}, is a Maude extension that introduces probabilities to the language. The underlying theory behind PMaude are  \textit{probabilistic rewrite theories} which correspond to an extension of rewrite theories. Probabilistic rewrite theories can be expressed as tuple $\mathscr{R}_p = (\Sigma, E, L, R, \pi)$, where $(\Sigma, E, L, R,)$ is a rewrite theory and $\pi$ is a function that assigns to each rewrite rule $r \in R$ a probability, given the current model state or configuration. This probability will determine if a rule may or may not be executed in the following system transition. The general form of probabilistic rewrite rules, both unconditional and conditional respectively is:
\begin{align*}
    l &: t(\overrightarrow{x}) \rightarrow t'(\overrightarrow{x}, \overrightarrow{y}) \; \text{if} \; C(\overrightarrow{x}) \; \textbf{with probability} \; \overrightarrow{y} := \pi_r(\overrightarrow{y}) \\
    l' &: t(\overrightarrow{x}) \rightarrow t'(\overrightarrow{x}, \overrightarrow{y}) \; \textbf{with probability} \; \overrightarrow{y} := \pi_r(\overrightarrow{y})  
\end{align*}
Where $\overrightarrow{x}$ is the set of variables of the model,  $\overrightarrow{y}$ is the set of new variables accessible in the following model state and $C(\overrightarrow{x})$ is the conjunction of conditions over the set $\overrightarrow{x}$. Moreover, $l, l'$ are labels in $L$, $t,t'$ are terms in the signature $\Sigma$ and $\pi_r$ corresponds to the probability function assigned to the specific rule $r \in R$. 
%provide the clock example and explain it


\begin{example}
\normalfont
To exemplify this new notion, let's consider the PMaude module, presented in \cite{Agha2006}: \\
\begin{maude}[mathescape=true]
pmod EXPONENTIAL-CLOCK is
  --- import positive real number module
  protecting POSREAL .

  --- imports PMaude module that defines
  --- EXPONENTIAL, BERNOULLI, GAMMA, etc.
  protecting PMAUDE .

  --- declare a sort Clock
  sort Clock .
  --- declare a constructor operator for Clock
  op clock : PosReal PosReal => Clock .
  --- declares a constructor operator for a broken clock
  op broken : PosReal PosReal => Clock .

  --- T is used to represent time of clock,
  --- C represents charge in the clocks battery,
  --- t represents time increment of the clock
  vars T C t : PosReal . var B : Bool .
  
  rl [advance]: clock(T,C) =>
                      if B then
                           clock(T+t,C - $\frac{\text{C}}{1000}$)
                      else
                           broken(T,C - $\frac{\text{C}}{1000}$)
                      fi
                with probability B:=BERNOULLI($\frac{\text{C}}{1000}$) 
                                and 
                                t:=EXPONENTIAL(1.0).
                
  rl [reset]: clock(T,C) => clock(0.0,C) .
endpm
\end{maude}
This model represents a clock that works with a battery. The idea is to model the behavior of the clock, when the battery starts depleting: when the charge of the battery is high, then the probability that the clock breaks is low. Conversely, when the clock's battery is low, the clock has a higher probability of breaking. In this probabilistic system module, the clock is represented as a term \texttt{clock(T,C)}, where \texttt{T} is the time and \texttt{C} is the clock's battery. The main probabilistic rewrite rule \texttt{advance} represents the ``ticks" of the clock. If the boolean value \texttt{B} is true, then the clocks ticks normally and the new time will be the current time \texttt{T} plus an increment \texttt{t}. Also, the charge of the clock will be reduced by a thousandth of the current's clock's charge. If \texttt{B} is false, then the clock will break and move to the state \texttt{broken(T,C - $\frac{\texttt{C}}{1000}$)}. The constructor \texttt{broken} of sort \texttt{Clock} represents the broken state of the clock. To incorporate the probabilistic choice of event for the clock's state (either ticking or breaking), the value \texttt{B} is chosen probabilistically, based on the charge of the clock. This is done by the \texttt{BERNOULLI} function, which receives a float number and returns a boolean value that is distributed according to the Bernoulli distribution with mean $\frac{\texttt{C}}{1000}$. Therefore, the lesser the charge left in the battery, the greater is the probability that the clock will break. The value \texttt{t} is also probabilistically determined, in this case, by an exponential distribution function.
There is also a second rewriting rule, that resets the clock to its initial state \texttt{clock(0.0, C)}. It is important to remark that this model has both probabilistic and non-deterministic choice: The state of the clock depends on a probability function but the choice of rewriting rules is done non-dereministically by Maude's fair scheduler.
\end{example}


PMaude modules can be transformed into regular system modules in Maude. This is done with three key modules: \texttt{COUNTER}, \texttt{RANDOM} and \texttt{SAMPLER}. The built-in \texttt{COUNTER} module in Maude consists of the rewriting rule
\\
\begin{maude}
rl counter => N:Nat .
\end{maude}
that rewrites the constant counter to a natural number. The module is built to guarantee that every time the constant counter is replaced with a natural number \texttt{N}, this natural number corresponds to the successor of the natural number obtained in the previous use of the rule. The built-in \texttt{RANDOM} module provides a random number generator function, called \texttt{random}. Lastly, the \texttt{SAMPLER} module specifies the sampling functions for different probability functions. For example, for the previous clock example, the needed functions will be:
\\
\begin{maude}
op EXPONENTIAL : PosReal -> PosReal .
op BERNOULLI : PosReal -> Bool .
\end{maude}
that are defined as:
\\
\begin{maude}
rl EXPONENTIAL(R) => (- log(rand)) / R .
rl BERNOULLI(R) => if rand < R then true else false fi .
\end{maude}
The value \texttt{rand} in both of the rules is defined as:
\\
\begin{maude}
rl [rnd] : rand => float(random(counter + 1) / 4294967296) .
\end{maude}
and it is rewritten in each step to a random number between 0 and 1. The number 4294967296 is used to divide the number returned by \texttt{random}, since it is the maximum number the function can return. The resulting Maude system module \cite{Agha2006} is:
\\
\begin{maude}
mod EXPONENTIAL-CLOCK-TRANSFORMED is 
  --- The SAMPLER mode includes the COUNTER and RANDOM modules
  protecting SAMPLER .
  protecting POSREAL .
  
  sort Clock . 
  op clock : Nat Float -> Clock [ctor] . 
  op broken : Nat Float -> Clock [ctor] . 
  
  vars T C : PosReal . 
  
  rl clock(T,C) => if BERNOULLI($\frac{\text{C}}{1000}$) then 
                        clock(T + EXPONENTIAL(1.0), C - $\frac{\text{C}}{1000}$) 
                   else 
                        broken(T,C - $\frac{\text{C}}{1000}$)
                   fi .
  
  rl [reset]: clock(T,C) => clock(0.0,C) .
endm
\end{maude}

\section{VeStA, PVeStA, MultiVeStA, QuaTEx and MultiQuaTEx}
%explain what is VeStA
VeStA \cite{Vesta} is a tool (implemented in Java) for statistical analysis of probabilistic systems. It supports statistical model checking and statistical evaluation of expected values of temporal expressions. These expressions can be constructed using the query language of  \textit{Quantitative Temporal Expression} or QuaTEx \cite{Agha2006}, and analyzed by VeStA using \textit{Monte Carlo simulations}. The general process to use VeStA and analyze the properties of a probabilistic model, is the following:
\begin{enumerate}
    \item Create a probabilistic system in the supported modeling languages, e.g. probabilistic rewrite theories specified in PMaude.
    \item Define the model properties that are going to be analyzed using the supported temporal expressions, e.g. QuaTEx.
    \item Run Monte Carlos simulations using VeStA, over the model and the defined properties, specifying the simulation parameters.
    \item Get the expected value of the temporal expressions specified in step 2.
\end{enumerate}
%explain how Quatex works
The syntax of a QuaTEx expression is defined in Figure \ref{fig:multivesta}. The reader can find an in depth explanation of this syntax and how QuaTEx queries evaluate in \cite{Agha2006,multivesta}. For now we will define a QuaTEx expression as the expected value of a temporal logic predicate over state observations that returns a real number. For example the QuaTEx expression \texttt{eval E[$PExp$]} returns the expected value of the real number returned by the temporal logic predicate $PExp$ (or also called \textit{path expression} in the syntax of QuaTEx).  
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.4]{images/quatex1.png}
    \caption{QuaTEx syntax, taken from \cite{multivesta}}
    \label{fig:multivesta}
\end{figure}

Using the previous definition of QuaTEx queries, let's suppose that we want to find the expected value of a QuaTEx query \texttt{eval E[$PExp$]} using VeStA (we will refer to the expected value of the QuaTEx query obtained by VeStA as $\hat{x}$, and to the real expected value as $x$). To obtain $\hat{x}$, VeStA uses 2 user-defined parameters $\alpha$ and $\delta$. With these parameters, VeStA runs $n$ simulations, until $n$ is large enough to obtain a \textit{confidence interval} (CI) with probability $(1-\alpha) * 100\%$ bounded by $\delta$, i.e an interval $[\hat{x} - \frac{\delta}{2},\hat{x} + \frac{\delta}{2}]$ where the probability that $x \in [\hat{x} - \frac{\delta}{2},\hat{x} + \frac{\delta}{2}]$ is $(1-\alpha) * 100\%$. In other words, if VeStA calculates the expected value of a QuaTEx query as $\hat{x}$, then the probability that the real expected value of the query (represented as $x$) is in the interval $[\hat{x} - \frac{\delta}{2},\hat{x} + \frac{\delta}{2}]$, is $(1-\alpha) * 100\%$.

VeStA and Quatex have also seen many upgrades during time. For example, the authors in \cite{AlTurki2011} present an extension of VeStA called PVeStA. This tool allows to run parallelized algorithms for statistical model checking using a client-server architecture. Furthermore \cite{multivesta} presents an extension of both VeStA and PVeStA called MultiVeStA, that extends the QuaTEx language to MultiQuaTEx, by allowing to query more state measures at a time. This improves the usability and the performance of the language. The extension also integrates existing discrete event simulators in addition to the originally supported ones, and improves the presentation of results, by including graphs of the results of the simulations. In Chapter 5, a detailed explanation on how to use MultiVeStA with PMaude specifications, will be given.
 

To illustrate how statistical analysis of probabilistic rewrite theories specified in Pmaude works, the MultiVeStA tool will be used to run simulations over the clock model specified in the previous section and verify properties over it. To do this, the steps to modify and run the clock example are:
\begin{enumerate}
    \item Define the PMaude model's states as configurations using object-oriented programming in Maude and define the system transitions as rewriting rules between configurations.
    \item Implement a scheduler that chooses deterministically the event that is going to be executed.
    \item Include the necessary elements of MultiVeStA inside the model's definition.
    \item Define an analysis module to define the model observations used by the MultiQuaTEx queries.
    \item Define the MultiQuaTEx queries that represent the model's properties that want to be checked.
    \item Specify the simulation parameters.
    \item Run the simulations using the the probabilistic model, the MultiQuaTEx queries and the simulation parameters.
\end{enumerate} 
For the first step, we will create a class named \texttt{Clock} defined as:
\\
\begin{maude}
< Oid : Clock | time: Nat, battery: Float, state: State > .
\end{maude}
where the sort \texttt{State} is defined by two constants \texttt{working} and \texttt{broken}. The initial state of the system is then defined as:
\\
\begin{maude}
< myClock : Clock  | time: 0, battery: 1000.0, state: working >
\end{maude}
And the rewrite rule that simulates the clock's ticks is:
\\
\begin{maude}
rl [clockTick] :
    < cl : Clock  | time: T, battery: C, state: working > 
  =>
    if sampleBernoulli(C / 1000.0) then
      < cl : Clock  | time: s(T), battery: (C - (C / 1000.0)),
        state: working >
    else
      < cl : Clock  | time: T, battery: C, state: broken >
    fi .
\end{maude}
In this model, instead of having the exponential function to determine the time increment, to simplify the model it will be fixed to 1. Afterwards, it is necessary to implement the structures required by MultiVeStA to run the simulations. This structures control the simulation's time and schedules the following rules to be applied. Then, the state observations can be defined. These observations correspond to the \texttt{rval($i$)} predicate defined in \cite{Agha2006,multivesta}, and for this example three \texttt{rval} predicates are defined as:
\begin{itemize}
    \item \texttt{s.rval("eTime")}: returns the time value of the clock in state $s$, as a float number.
    \item \texttt{s.rval("eBattery")}: returns the battery level of the clock in state $s$.
    \item \texttt{s.rval("isBrk")}: returns 1.0 if the clock is \texttt{broken} in state $s$ or 0.0 if the clock is \texttt{working} in state $s$.
\end{itemize}
Using these predicates, two MultiQuaTEx formulas are defined:
\\
\begin{maude2}
PTime() = if ( s.rval("isBrk") == 1.0 ) 
          then s.rval("eTime") else # PTime() fi ;
eval E[ PTime() ] ;

#------------------------------------------------------------

PBattery() = if ( s.rval("isBrk") == 1.0 ) 
             then s.rval("eBattery") else # PBattery() fi ;
eval E[ PBattery() ] ;
\end{maude2}
The first formula states that if the clock is broken (i.e. \texttt{s.rval("isBrk") == 1.0}) then the current time of the clock is returned (i.e. \texttt{s.rval("eTime")}). If not, the query calls itself in the following system state (i.e. \texttt{\# PTime()}). The other query has the same behavior as the previous one, but instead of \texttt{s.rval("eTime")} is \texttt{s.rval("eBattery")}. Therefore, the answer returned by the first query corresponds to the expected value of the clock's time when it breaks, and the answer returned by the second query is the expected value of the clock's battery when it breaks. Once the simulations are executed with the clock probabilistic model, the two MultiQuaTEx formulas, and parameters $\alpha = 0.05$ and $\delta = 1$, the obtained results for both queries were:
\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
Property & ObtainedValue    & Variance         & CI                 \\ \hline
PTime()  & 39.7909482758621 & 422.729500809641 & 0.999968586222357         \\ \hline
\end{tabular}
\end{table}
%----------------------------------------------------------
\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
Property   & ObtainedValue   & Variance         & CI                 \\ \hline
PBattery() & 961.13204082891 & 387.863387550541 & 0.999651593005253 \\ \hline
\end{tabular}
\end{table}

This means that the expected value of the time when the clock breaks has a probability of $(1-\alpha)*100\% = 95\%$ to be inside the interval $[\frac{\delta}{2} - 39.79, \frac{\delta}{2} + 39.79] = [39.29, 40.29]$, and the expected value of the battery level when the clock breaks has a probability of $(1-\alpha)*100\% = 95\%$ to be inside the interval $[\frac{\delta}{2} - 961.13, \frac{\delta}{2} + 961.13] = [960.63, 961.63]$.

%----------------------

\begin{comment}

\section{A Rewriting Logic Semantics for Probabilistic Event-B}
The rewriting logic approach to probabilistic Event-B \cite{Olarte}, introduces a method for translating probabilistic Event-B models to PMaude models that are executable in PVeStA. Formally speaking, it is a map $[[ \cdot ]]: \mathscr{M} \rightarrow \mathscr{R}_\mathscr{M}$ from a probabilistic event machine to a probabilistic rewrite theory. There are two main steps for this transformation:

\begin{enumerate}
    \item The first one is to specify a rewrite theory $\mathscr{R}$ that defines the types, sets, constants of the Event-B's context, and the infrastructure needed to encode variables and events of a probabilistic Event-B machine.
    \item After that, $\mathscr{R}$ is extended with equations and rewrite rules that correspond to the events in the machine $\mathscr{M}$.
\end{enumerate}
This rewrite theory $\mathscr{R}$, is constructed with two main components: A Maude specification of an Event-B context and an Event-B machine. The Maude version of the context is:
\\
\begin{maude}
mod EBCONTEXT is 
  pr CONFIGURATION . pr EB-TYPE  . pr MAP{Qid, EBSet} . pr MAP{Qid, EBType} .
  --- Names for contexts
  subsort Qid < Oid .
  --- Class for contexts
  op Context  : -> Cid . 
  --- Context's user-defined sets
  op sets :_      : Map{Qid , EBSet}  -> Attribute .
  --- Context's constants
  op constants :_ : Map{Qid , EBType} -> Attribute .
  --- Building a context
  op init-context : Qid -> Object .                         
  var Q : Qid .
  eq init-context(Q) = < Q : Context | sets : init-sets,
                         constants : init-constants  > .
  --- Operators to be instantiated by the implementation of the context
  op init-sets : ->  Map{Qid , EBSet} . --- Building deferred sets
  op init-constants : ->  Map{Qid , EBSet} . --- Initializing constants 
endm
\end{maude}

\texttt{EBtype} encodes the values of the model constants, by wrapping all the possible types a constant can have and \texttt{EBSet} contains the definition of finite sets. This Maude version of the context is based on the \texttt{CONFIGURATION} theory, previously explained in Section 2.5. A context is represented as an object of the class \texttt{Context}, with two attributes that are \texttt{sets} and \texttt{constants}. The attribute \texttt{sets} contains all the sets identifiers paired with their respective values, and \texttt{constants} contains all the constant identifiers paired with their respective values. The context attributes' values are initialized using the \texttt{init-context, init-sets} and \texttt{init-constants} operators. 

The Event-B machine, is represented with the following Maude specification:
\\
\begin{maude}
mod EBMACHINE is
  inc EBCONTEXT  . --- Context specification. 
  op Machine  : -> Cid . --- Class for machines
  op variables :_ : Map{Qid , EBType} -> Attribute . --- Machine's variables 
  --- Instantiated by the machine at hand
  op init-variables : ->  Map{Qid , EBType} . 
  op init-machine : Qid Qid -> Object . --- Initial state of the machine
  vars QM QC : Qid .
  --- Configuration defining the machine QM and its context QC
  eq init-machine(QC, QM)  = 
                  init-context(QC)                              --- Context 
                  < QM : Machine | variables : init-variables > --- Variables
                  < events : Events | state: init-events >.     --- Events 
[...] --- event specification explained below
\end{maude}
Like the context, the machine is also represented using object-oriented programming in Maude. A machine is an object of the class \texttt{Machine} with only one attribute \texttt{variables}, that correspond to all the variable identifiers paired with their respective value. The previously explained definitions for the Maude version of context and machine, correspond to the rewrite theory $\mathscr{R}$, which can be extended in two steps, to obtain $\mathscr{R}_\mathscr{M}$: adding the initialization event, that will fill the initial configuration of the model with the initial values of all the variables, and the second step is to add the different equations and rewrite rules that encode the probabilistic Event-B events. The former is represented as an equation that initializes \texttt{init-variables}, of the form:
\\
\begin{maude}
    eq init-variables = ('v1 |-> val1, ... , ('vn   |-> valn)
\end{maude}

Where every $v_1 ... v_n$ are the model's variables and $val_1..val_n$ are their corresponding values. The latter is achieved by:

\begin{enumerate}
    \item A deterministic mechanism that determines if an event is enabled or not, given the current state of the machine
    \item A probabilistic rule that chooses the next event to be executed, according to the weights of the enabled events
    \item For each event, a rule that chooses probabilistically the value of the event parameters and probabilistic assignments. After that, the state of the machine is updated accordingly. This rule corresponds to an observable transition of the machine $\mathscr{M}$.
\end{enumerate}
\textbf{Events' states (1)} The possible states for an event are defined as:
\\
\begin{maude}
 sort EvState . --- States of events
 ops blocked unknown execute : -> EvState . 
 op enable : NzNat -> EvState . --- Enable with a given weight w > 0
\end{maude}
where \texttt{blocked} means that the event cannot be executed in the current machine configuration, \texttt{unknown} means that the event's state hasn't been computed, \texttt{execute} implies that the event will be executed in the following transition and \texttt{enable} states that an event is enabled for execution in the given machine configuration, with an specific weight. The definition for an event is:
\\
\begin{maude}
   sort Event LEvent . --- Events and list of events
   op ev : Qid EvState -> Event . --- ID of the event and its state
   op state:_ : LEvent -> Attribute . --- Attribute for objects of class Events   
   op init-events : -> LEvent . --- To be instantiated by the machine at hand
\end{maude}
Each event has the form $ev(e_i, st_i)$, where $e_i$ is the event identifier and $st_i$ is the state of the event. When the machine is initialized, every event $e_i$ (represented as the event list \texttt{init-events}) starts as $ev(e_i, unknown)$. In the following machine configurations, the events' states are updated deterministically with an equation from \texttt{unknown} to \texttt{enabled} or \texttt{blocked}, depending on the guards of the event and the current state of the machine.

\textbf{Determine next event to execute (2)} In order to probabilistically select the next event that will be executed, using the event weights of the enabled events, the following conditional rule is used:
\\
\begin{maude}
crl [next-event] :  < events : Events | state: LE > => 
                    < events : Events | ev(pick(LEA,
                      rand(max-value(LEA))), execute) >
if     all-ready(LE) --- All e in LE is in state either blocked or enabled 
   /\  one-firable(LE) --- At least one event is enabled 
   /\  LE' := filter(LE) --- Extract the enabled events
   /\  LEA := accumulate(LE') . --- Accumulate the weights 
\end{maude}
this rule states that if there exists one or more enabled events (no deadlock), then one of the enabled events is picked, following a uniform distribution on the interval $[0, W)$ where $W$ is the sum of all the weights of enabled events. The state of the selected event will the be changed to \texttt{execute}.

\textbf{Actions in events (3)} After an event is chosen for execution, the variable values need to change according to the event actions. Both deterministic an probabilistic assignments can be done  by simply changing the state configuration using a standard rewrite rule, with the slight difference that for probabilistic assignments or assignments that involve a parameter, a function that simulates a uniform distribution (like the one used for selecting events) will be used to select the new variable value or the value of the parameter in the assignment.
\end{comment}








